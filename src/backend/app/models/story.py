"""
Story model for member contributions and achievements.

Stories are the core content units in STONESOUP, representing contributions,
achievements, and experiences that members share. Each story:
- Belongs to a specific cauldron (multi-tenancy)
- Can be linked to multiple members (many-to-many)
- Has an embedding for semantic search
- Includes a confidence score for AI-generated content
- Tracks its lifecycle through status enum

The Stone Soup metaphor: Each story is an "ingredient" that members
contribute to the collective knowledge cauldron.
"""
from typing import Optional, Dict, Any, List
from datetime import datetime
from enum import Enum
from sqlalchemy import (
    Column, String, Text, Float, Boolean, DateTime, JSON, Index,
    ForeignKey, Table, Enum as SQLEnum, Integer
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from pgvector.sqlalchemy import Vector
import uuid

from app.db.base_class import BaseModel, CauldronMixin


class StoryStatus(str, Enum):
    """
    Status enum for stories tracking their lifecycle.
    
    - DRAFT: Story is being created/edited, not yet published
    - PENDING_REVIEW: Story submitted for review (if moderation enabled)
    - PUBLISHED: Story is live and visible
    - ARCHIVED: Story is hidden but retained for historical purposes
    - REJECTED: Story was rejected during review
    """
    DRAFT = "draft"
    PENDING_REVIEW = "pending_review"
    PUBLISHED = "published"
    ARCHIVED = "archived"
    REJECTED = "rejected"


class StoryType(str, Enum):
    """
    Type enum for different kinds of stories.
    
    - ACHIEVEMENT: Specific accomplishment or milestone
    - EXPERIENCE: Work experience or project
    - SKILL_DEMONSTRATION: Showcase of particular skills
    - TESTIMONIAL: Endorsement from colleague/client
    - CASE_STUDY: Detailed project case study
    - THOUGHT_LEADERSHIP: Article or insight
    """
    ACHIEVEMENT = "achievement"
    EXPERIENCE = "experience"
    SKILL_DEMONSTRATION = "skill_demonstration"
    TESTIMONIAL = "testimonial"
    CASE_STUDY = "case_study"
    THOUGHT_LEADERSHIP = "thought_leadership"


# Association table for many-to-many relationship between stories and members
# This table includes cauldron_id to ensure proper multi-tenancy constraints
story_members = Table(
    'story_members',
    BaseModel.metadata,
    Column('story_id', UUID(as_uuid=True), ForeignKey('stories.id', ondelete='CASCADE'), primary_key=True),
    Column('member_id', UUID(as_uuid=True), ForeignKey('members.id', ondelete='CASCADE'), primary_key=True),
    Column('cauldron_id', UUID(as_uuid=True), ForeignKey('cauldrons.id', ondelete='CASCADE'), nullable=False, 
           comment="Cauldron ID for multi-tenancy - must match both story and member cauldron_id"),
    Column('role', String, nullable=True, comment="Member's role in the story (e.g., 'author', 'contributor')"),
    Column('created_at', DateTime, default=datetime.utcnow, nullable=False),
    Index('ix_story_members_story_id', 'story_id'),
    Index('ix_story_members_member_id', 'member_id'),
    Index('ix_story_members_cauldron_id', 'cauldron_id'),
)


class Story(BaseModel, CauldronMixin):
    """
    Story model representing contributions and achievements in the talent marketplace.
    
    Stories are the building blocks of member profiles, showcasing their
    experiences, skills, and accomplishments. They can be:
    - Created manually by members
    - Generated by AI based on member interactions
    - Linked to multiple members for collaborative projects
    - Searched semantically using embeddings
    """
    
    __tablename__ = "stories"
    
    # Basic Information
    title = Column(
        String(255),
        nullable=False,
        index=True,
        comment="Story title for display and search"
    )
    
    content = Column(
        Text,
        nullable=False,
        comment="Full story content in markdown format"
    )
    
    summary = Column(
        Text,
        nullable=True,
        comment="Brief summary for previews and search results"
    )
    
    # Story Type and Status
    story_type = Column(
        SQLEnum(StoryType),
        default=StoryType.EXPERIENCE,
        nullable=False,
        index=True,
        comment="Type of story for categorization"
    )
    
    status = Column(
        SQLEnum(StoryStatus),
        default=StoryStatus.DRAFT,
        nullable=False,
        index=True,
        comment="Current status in the publication lifecycle"
    )
    
    # AI and Embedding Fields
    embedding = Column(
        Vector(1536),
        nullable=True,
        comment="Vector embedding for semantic search (1536 dims for OpenAI)"
    )
    
    confidence_score = Column(
        Float,
        nullable=True,
        comment="AI confidence score (0-1) for generated content"
    )
    
    ai_generated = Column(
        Boolean,
        default=False,
        nullable=False,
        comment="Whether this story was generated by AI"
    )
    
    generation_prompt = Column(
        Text,
        nullable=True,
        comment="The prompt used to generate this story (if AI-generated)"
    )
    
    # Metadata and Tags
    tags = Column(
        JSON,
        default=list,
        nullable=False,
        comment="Array of tags for categorization"
    )
    
    skills_demonstrated = Column(
        JSON,
        default=list,
        nullable=False,
        comment="Skills showcased in this story"
    )
    
    # Dates and Timeline
    occurred_at = Column(
        DateTime,
        nullable=True,
        comment="When the story event occurred (different from created_at)"
    )
    
    published_at = Column(
        DateTime,
        nullable=True,
        index=True,
        comment="When the story was published"
    )
    
    # External References
    external_url = Column(
        String,
        nullable=True,
        comment="Link to external content (portfolio, article, etc.)"
    )
    
    company = Column(
        String,
        nullable=True,
        index=True,
        comment="Company/organization associated with the story"
    )
    
    # Metrics and Engagement
    view_count = Column(
        Integer,
        default=0,
        nullable=False,
        comment="Number of times the story has been viewed"
    )
    
    like_count = Column(
        Integer,
        default=0,
        nullable=False,
        comment="Number of likes/endorsements"
    )
    
    # Review and Moderation
    reviewed_by_id = Column(
        UUID(as_uuid=True),
        ForeignKey('members.id', ondelete='SET NULL'),
        nullable=True,
        comment="ID of the member who reviewed this story"
    )
    
    reviewed_at = Column(
        DateTime,
        nullable=True,
        comment="When the story was reviewed"
    )
    
    review_notes = Column(
        Text,
        nullable=True,
        comment="Internal notes from the review process"
    )
    
    # Additional Metadata
    extra_metadata = Column(
        JSON,
        default=dict,
        nullable=False,
        comment="Additional flexible metadata"
    )
    
    # Relationships
    members = relationship(
        "Member",
        secondary=story_members,
        back_populates="member_stories",
        lazy="selectin"
    )
    
    reviewer = relationship(
        "Member",
        foreign_keys=[reviewed_by_id],
        back_populates="reviewed_stories"
    )
    
    # Indexes for performance
    __table_args__ = (
        Index("ix_stories_cauldron_status", "cauldron_id", "status"),
        Index("ix_stories_cauldron_type", "cauldron_id", "story_type"),
        Index("ix_stories_published_at", "published_at"),
        Index("ix_stories_tags", "tags", postgresql_using="gin"),
        Index("ix_stories_skills", "skills_demonstrated", postgresql_using="gin"),
        Index("ix_stories_ai_generated", "ai_generated"),
        
        # Create HNSW index for vector similarity search
        # HNSW (Hierarchical Navigable Small World) provides better performance
        # for high-dimensional vector searches compared to IVFFlat
        Index(
            "ix_stories_embedding_hnsw",
            "embedding",
            postgresql_using="hnsw",
            postgresql_with={"m": 16, "ef_construction": 64},
            postgresql_ops={"embedding": "vector_cosine_ops"}
        ),
    )
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert story to dictionary representation."""
        return {
            **super().to_dict(),  # Include base fields
            "cauldron_id": str(self.cauldron_id) if self.cauldron_id else None,
            "title": self.title,
            "content": self.content,
            "summary": self.summary,
            "story_type": self.story_type.value if self.story_type else None,
            "status": self.status.value if self.status else None,
            "confidence_score": self.confidence_score,
            "ai_generated": self.ai_generated,
            "generation_prompt": self.generation_prompt,
            "tags": self.tags or [],
            "skills_demonstrated": self.skills_demonstrated or [],
            "occurred_at": self.occurred_at.isoformat() if self.occurred_at else None,
            "published_at": self.published_at.isoformat() if self.published_at else None,
            "external_url": self.external_url,
            "company": self.company,
            "view_count": self.view_count,
            "like_count": self.like_count,
            "reviewed_by_id": str(self.reviewed_by_id) if self.reviewed_by_id else None,
            "reviewed_at": self.reviewed_at.isoformat() if self.reviewed_at else None,
            "review_notes": self.review_notes,
            "extra_metadata": self.extra_metadata or {},
            "member_ids": [str(member.id) for member in self.members] if self.members else [],
        }
    
    def __repr__(self) -> str:
        return f"<Story {self.title[:50]}...>"
    
    @property
    def is_published(self) -> bool:
        """Check if the story is currently published."""
        return self.status == StoryStatus.PUBLISHED
    
    @property
    def is_editable(self) -> bool:
        """Check if the story can be edited."""
        return self.status in [StoryStatus.DRAFT, StoryStatus.REJECTED]
    
    def publish(self) -> None:
        """Publish the story."""
        self.status = StoryStatus.PUBLISHED
        self.published_at = datetime.utcnow()
    
    def archive(self) -> None:
        """Archive the story."""
        self.status = StoryStatus.ARCHIVED
    
    def submit_for_review(self) -> None:
        """Submit the story for review."""
        self.status = StoryStatus.PENDING_REVIEW
    
    def approve(self, reviewer_id: UUID) -> None:
        """Approve the story after review."""
        self.status = StoryStatus.PUBLISHED
        self.published_at = datetime.utcnow()
        self.reviewed_by_id = reviewer_id
        self.reviewed_at = datetime.utcnow()
    
    def reject(self, reviewer_id: UUID, notes: str) -> None:
        """Reject the story with notes."""
        self.status = StoryStatus.REJECTED
        self.reviewed_by_id = reviewer_id
        self.reviewed_at = datetime.utcnow()
        self.review_notes = notes